#ifndef INTERPRETER_PARSER_H
#define INTERPRETER_PARSER_H

#include <stdbool.h>
#include "expr.h"
#include "token_types.h"
#include "cvector.h"


union Expr expression(void);
union Expr equality(void);
union Expr comparison(void);
union Expr term(void);
union Expr factor(void);
union Expr unary(void);
union Expr primary(void);
bool parser_match(TokenTypeEnum *typeList, size_t len);
bool parser_check(TokenTypeEnum type);
Token parser_advance(void);
bool parser_is_at_end(void);
Token parser_peek(void);
Token parser_previous(void);
union Expr parser_parse_binary(union Expr *expr, TokenTypeEnum l[]);
//struct Token consume(TokenType token);


size_t parser_current = 0;
cvector_vector_type(Token) parser_tokens;

inline union Expr expression(void) {
    return equality();
}

inline union Expr equality(void) {
    union Expr expr = comparison();

    TokenTypeEnum l[] = {BANG_EQUAL, EQUAL_EQUAL};
    return parser_parse_binary(&expr, l);
}

inline union Expr comparison(void) {
    union Expr expr = term();

    TokenTypeEnum l[] = {GREATER, GREATER_EQUAL, LESS, LESS_EQUAL};
    return parser_parse_binary(&expr, l);
}

inline union Expr term(void) {
    union Expr expr = factor();

    TokenTypeEnum l[] = {MINUS, PLUS};
    return parser_parse_binary(&expr, l);
}

inline union Expr factor(void) {
    union Expr expr = unary();

    TokenTypeEnum l[] = {SLASH, STAR};
    return parser_parse_binary(&expr, l);
}

inline union Expr unary(void) {
    TokenTypeEnum l[] = {BANG, MINUS};
    if (parser_match(l, 2)) {
        Token operator = parser_previous();
        union Expr right = unary();
        union Expr _unary = {
                .unary = {
                        .operator = operator,
                        .right    = &right,
                }
        };
        return _unary;
    }
    return primary();
}

inline union Expr primary(void) {
    {  // FALSE
        TokenTypeEnum l[] = {FALSE};
        if (parser_match(l, 1)) {
            union Expr literal = {
                    .literal = {
                            .value = false
                    }
            };
            return literal;
        }
    }
    {  // TRUE
        TokenTypeEnum l[] = {TRUE};
        if (parser_match(l, 1)) {
            union Expr literal = {
                    .literal = {
                            .value = false
                    }
            };
            return literal;
        }
    }
    {  // NULL
        TokenTypeEnum l[] = {_NULL};
        if (parser_match(l, 1)) {
            union Expr literal = {
                    .literal = {
                            .value = false
                    }
            };
            return literal;
        }
    }
    {  // NUMBER, STRING
        TokenTypeEnum l[] = {NUMBER, STRING};
        if (parser_match(l, 2)) {
            // generated by ai
            LiteralUnion _lit = parser_previous().literal;
            void *void_ptr = &_lit;

            union Expr literal = {
                    .literal = {
                            .value = void_ptr
                    }
            };
            return literal;
        }
    }
    {  // LEFT_PAREN
        union Expr expr = expression();
        // consume(RIGHT_PAREN, "Expect ')' after expression.");
        union Expr _expr = {
                .grouping = {
                        .expression = &expr
                }
        };
        return _expr;
    }
}

inline bool parser_match(TokenTypeEnum *typeList, size_t len) {
    for (size_t i = 0; i < len; i++) {
        typeList++;
        if (parser_check(*typeList)) {
            parser_advance();
            return true;
        }
    }
    return false;
}

inline bool parser_check(TokenTypeEnum type) {
    if (parser_is_at_end()) return false;
    return parser_peek().TokenTypes == type;
}

inline bool parser_is_at_end(void) {
    return parser_peek().TokenTypes == END_OF_FILE;
}

inline Token parser_advance(void) {
    if (!parser_is_at_end()) parser_current++;
    return parser_previous();
}

inline Token parser_peek(void) {
    return *cvector_at(parser_tokens, parser_current);
}

inline Token parser_previous(void) {
    return *cvector_at(parser_tokens, parser_current - 1);
}

inline union Expr parser_parse_binary(union Expr *expr, TokenTypeEnum l[]) {
    while (parser_match((TokenTypeEnum*) l, 4)) {
        Token operator = parser_previous();
        union Expr right = term();
        union Expr _expr = {
                .binary = {
                        .left     = &expr,
                        .operator = operator,
                        .right    = &right
                }
        };
        *expr = _expr;
    }
    return *expr;
}

#endif // INTERPRETER_PARSER_H
